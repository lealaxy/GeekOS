/*
 * ELF executable loading
 * Copyright (c) 2003, Jeffrey K. Hollingsworth <hollings@cs.umd.edu>
 * Copyright (c) 2003, David H. Hovemeyer <daveho@cs.umd.edu>
 * $Revision: 1.29 $
 * 
 * This is free software.  You are permitted to use,
 * redistribute, and modify it as specified in the file "COPYING".
 */

#include <geekos/errno.h>
#include <geekos/kassert.h>
#include <geekos/ktypes.h>
#include <geekos/screen.h>  /* for debug Print() statements */
#include <geekos/pfat.h>
#include <geekos/malloc.h>
#include <geekos/string.h>
#include <geekos/user.h>
#include <geekos/elf.h>


/**
 * From the data of an ELF executable, determine how its segments
 * need to be loaded into memory.
 * @param exeFileData buffer containing the executable file
 * @param exeFileLength length of the executable file in bytes
 * @param exeFormat structure describing the executable's segments
 *   and entry address; to be filled in
 * @return 0 if successful, < 0 on error
 */
int Parse_ELF_Executable(char *exeFileData, ulong_t exeFileLength,
    struct Exe_Format *exeFormat)
{
    //TODO("Parse an ELF executable image");
    int i;
    elfHeader *head=(elfHeader*)exeFileData;//已装入内存的可执行文件所占用空间的起始地址
    programHeader *proHeader=(programHeader *)(exeFileData+head->phoff);//程序头部表在内存的起始地址
    KASSERT(exeFileData!=NULL);
    KASSERT(exeFileLength>head->ehsize+head->phentsize*head->phnum);
    KASSERT(head->entry%4==0);
    exeFormat->numSegments=head->phnum;//程序头部表的数目
    exeFormat->entryAddr=head->entry;//代码的入口地址
    for(i=0;i<head->phnum;i++)
{
   exeFormat->segmentList[i].offsetInFile=proHeader->offset;//段在可执行文件的偏移值
 exeFormat->segmentList[i].lengthInFile=proHeader->fileSize;//段在可执行文件的长度
 exeFormat->segmentList[i].startAddress=proHeader->vaddr;//段在内存的起始地址
 exeFormat->segmentList[i].sizeInMemory=proHeader->memSize;//段在内存中的大小
 exeFormat->segmentList[i].protFlags=proHeader->flags;//保护标志
    proHeader++;
}
return 0;
}  

